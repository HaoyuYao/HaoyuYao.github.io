<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Adverserial Patch</title>
    <url>/2023/03/12/Adverserial-Patch/</url>
    <content><![CDATA[<h1 id="l2距离"><a href="#l2距离" class="headerlink" title="l2距离"></a>l2距离</h1><p><a href="https://blog.csdn.net/qq_40714949/article/details/122373929">https://blog.csdn.net/qq_40714949/article/details/122373929</a></p>
<p>tie-dye pattern就是一种彩虹状的图像</p>
<p>攻击方法分类标准：</p>
<h2 id="假正性攻击-false-positive-与伪负性攻击-false-negative"><a href="#假正性攻击-false-positive-与伪负性攻击-false-negative" class="headerlink" title="假正性攻击(false positive)与伪负性攻击(false negative)"></a>假正性攻击(false positive)与伪负性攻击(false negative)</h2><span id="more"></span>

<p>假正性攻击：原本是错误的但被被攻击模型识别为正例的攻击(eg: 一张人类不可识别的图像，被DNN以高置信度分类为某一类)；<br>伪负性攻击：原本应该被正常识别但被被攻击模型识别错误的攻击(eg: 原本能够被正确的样本，在遭到对抗攻击后，被攻击模型无法对其正确分类)。ps: 我现在做的遇到的大部分攻击算法都是伪负性攻击算法。</p>
<h2 id="白盒攻击-white-box-与黑盒攻击-black-box-："><a href="#白盒攻击-white-box-与黑盒攻击-black-box-：" class="headerlink" title="白盒攻击(white box)与黑盒攻击(black box)："></a>白盒攻击(white box)与黑盒攻击(black box)：</h2><p>被攻击模型的模型参数可以被获取的被称为白盒攻击；<br>模型参数不可见的被称为黑盒攻击。</p>
<h2 id="有目标攻击-target-attack-和无目标攻击-non-target-attack-："><a href="#有目标攻击-target-attack-和无目标攻击-non-target-attack-：" class="headerlink" title="有目标攻击(target attack)和无目标攻击(non-target attack)："></a>有目标攻击(target attack)和无目标攻击(non-target attack)：</h2><p>有目标攻击：期望对抗样本被定向误识别为某一特定类别；<br>无目标攻击：仅仅希望对抗样本不能被识别的而没有指定目标类别。</p>
<h2 id="单步攻击-One-time-attack-和迭代攻击-Iteration-attack-："><a href="#单步攻击-One-time-attack-和迭代攻击-Iteration-attack-：" class="headerlink" title="单步攻击(One-time attack)和迭代攻击(Iteration attack)："></a>单步攻击(One-time attack)和迭代攻击(Iteration attack)：</h2><p>最典型的就是之前实现过过的FGSM([2])<br>I-FGSM([3])</p>
<h2 id="个体攻击-Individual-attack-和普适性攻击-Universal-attack-："><a href="#个体攻击-Individual-attack-和普适性攻击-Universal-attack-：" class="headerlink" title="个体攻击(Individual attack)和普适性攻击(Universal attack)："></a>个体攻击(Individual attack)和普适性攻击(Universal attack)：</h2><p>个体攻击向每个样本添加不同的扰动，大多数攻击方法都属于个体攻击(典型算法可见[4],[5])；<br>普适性攻击训练一个整个数据集通用的扰动。</p>
<h2 id="优化扰动-optimized-perturbation-和约束扰动-constrained-perturbation-："><a href="#优化扰动-optimized-perturbation-和约束扰动-constrained-perturbation-：" class="headerlink" title="优化扰动(optimized perturbation)和约束扰动(constrained perturbation)："></a>优化扰动(optimized perturbation)和约束扰动(constrained perturbation)：</h2><p>优化扰动表示扰动大小作为优化过程中的优化目标(典型算法算法可参考[6])，C&amp;W攻击（白盒攻击）算法是一种基于迭代优化的低扰动对抗样本生成算法。该算法设计了一个损失函数，它在对抗样本中有较小的值，但在原始样本中有较大的值，因此通过最小化该损失函数即可搜寻到对抗样本；<br>约束扰动表示所添加扰动仅需满足约束即可。<br>数据集和被攻击模型：</p>
<p>目前该领域最常用的数据集为MNIST, CIFAR 和ImageNet；<br>最常用的被攻击模型为LeNet, VGG, AlexNet,GoogLeNet, CaffeNet, and ResNet等</p>
<h1 id="单词补充"><a href="#单词补充" class="headerlink" title="单词补充"></a>单词补充</h1><ol>
<li>classifier : 分类的概念是在已有数据的基础上学会一个分类函数或构造出一个分类模型（即我们通常所说的分类器(Classifier)）。该函数或模型能够把数据库中的数据纪录映射到给定类别中的某一个，从而可以应用于数据预测。总之，分类器是数据挖掘中对样本进行分类的方法的统称，包含决策树、逻辑回归、朴素贝叶斯、神经网络等算法。</li>
<li>generalize 推广</li>
<li>network 在这里指神经网络</li>
<li>perturb 扰乱</li>
<li>imperceptible 感觉不到的，十分细微的</li>
<li>image-independent 与图片无关的</li>
<li>salient 显著的</li>
<li>state-of-the art 使用最先进技术的</li>
<li>varient 多样的</li>
<li>camouflaged 伪装的</li>
<li>constraint 约束，限制</li>
<li>control 对照组</li>
<li>appendix 附录</li>
</ol>
<h1 id="文章对照翻译"><a href="#文章对照翻译" class="headerlink" title="文章对照翻译"></a>文章对照翻译</h1><p>We present a method to create universal, robust, targeted adversarial image patches in the real world. The patches are universal because they can be used to attack any scene, robust because they work under a wide variety of transformations, and targeted because they can cause a classifier to output any target class. These adversarial patches can be printed, added to any scene, photographed, and presented to image classifiers; even when the patches are small, they cause the classifiers to ignore the other items in the scene and report a chosen target class</p>
<p>我们提出了一种在现实世界中创建通用的、鲁棒的、有针对性的对抗图像补丁的方法。补丁是通用的，因为它们可以用来攻击任何场景;健壮的，因为它们可以在各种各样的转换下工作;有针对性的，因为它们可以导致分类器输出任何目标类。这些对抗补丁可以打印，添加到任何场景，拍摄，并呈现给图像分类器;即使补丁很小，它们也会导致分类器忽略场景中的其他项目，并报告选定的目标类</p>
<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>Deep learning systems are broadly vulnerable to adversarial examples, carefully chosen inputs that cause the network to change output without a visible change to a human [15, 5]. These adversarial examples most commonly modify each pixel by only a small amount and can be found using a number of optimization strategies such as L-BFGS [15], Fast Gradient Sign Method (FGSM) [5], DeepFool [10], Projected Gradient Descent (PGD) [8], as well as the recently proposed Logit-space Projected Gradient Ascent (LS-PGA) [2] for discretized inputs. Other attack methods seek to modify only a small number of pixels in the image (Jacobian-based saliency map [11]), or a small patch at a fixed location of the image [13].</p>
<p>深度学习系统普遍容易受到对抗性例子的攻击，精心选择的输入会导致网络改变输出，而不会对人类产生可见的变化[15,5]。这些对抗的例子通常只对每个像素进行少量修改，并且可以使用许多优化策略，如L-BFGS[15]，快速梯度符号方法(FGSM) [5]， DeepFool[10]，投影梯度下降(PGD)[8]，以及最近提出的用于离散输入的logit空间投影梯度上升(LS-PGA)[2]。其他攻击方法只寻求修改图像中的少量像素(基于雅可比矩阵的显著图[11])，或图像[13]固定位置的小补丁。</p>
<p>Adversarial examples have been shown to generalize to the real world. Kurakin et al [7] demonstrated that when printed out, an adversarially constructed image will continue to be adversarial to classifiers even under different lighting and orientations. Athalye et al [3] recently demonstrated adversarial objects which can be 3d printed and misclassified by networks at different orientations and scales.</p>
<p>Their adversarial objects are designed to be subtle perturbations of a normal object (e.g. a turtle that has been adversarially perturbed to be classified as a rifle). Another work [13] showed that one can fool facial recognition software by constructing adversarial glasses. These glasses were targeted in that they could be constructed to impersonate any person, but were custom made for the attacker’s face, and were designed with a fixed orientation in mind. Even more recently, Evtimov et al [4] demonstrated various methods for constructing stop signs that are misclassified by models, either by printing out a large poster that looks like a stop sign, or by placing various stickers on a stop sign. In terms of defenses there has been substantial work on increasing the adversarial robustness of image models to small Lp perturbations of the input [8, 12, 16, 2].</p>
<p>对抗性的例子已经被证明可以推广到现实世界。Kurakin等[7]证明，当打印出来时，即使在不同的光照和方向下，对抗构造的图像也将继续对抗分类器。Athalye等[3]最近展示了可以在不同方向和规模上被网络3d打印和错误分类的对抗性物体。</p>
<p>它们的对抗性物体被设计成对正常物体的轻微扰动(例如，一只乌龟被对抗性扰动后被归类为步枪)。另一项研究[13]表明，人们可以通过构建对抗性眼镜来欺骗面部识别软件。这些眼镜是有针对性的，因为它们可以模仿任何人，但是为攻击者的脸定制的，并且在设计时考虑了固定的方向。甚至在最近，Evtimov等人[4]演示了各种构建被模型错误分类的停止标志的方法，要么打印出一个看起来像停止标志的大海报，要么在停止标志上放置各种贴纸。在防御方面，已经有大量工作用于提高图像模型对输入的小Lp扰动的对抗鲁棒性[8,12,16,2]。</p>
<p>As seen above, a majority of prior work has focused on attacking with and defending against either small or imperceptible changes to the input. In this work we explore what is possible if an attacker no longer restricts themselves to imperceptible changes. We construct an attack that does not attempt to subtly transform an existing item into another. Instead, this attack generates an image-independent patch that is extremely salient to a neural network. This patch can then be placed anywhere within the field of view of the classifier, and causes the classifier to output a targeted class. Because this patch is scene-independent, it allows attackers to create a physical-world attack without prior knowledge of the lighting conditions, camera angle, type of classifier being attacked, or even the other items within the scene</p>
<p>如上所述，大多数先前的工作都集中在对输入的微小或难以察觉的变化进行攻击和防御。在这项工作中，我们探索了如果攻击者不再局限于难以察觉的变化，那么可能会发生什么。我们构建的攻击不会试图巧妙地将现有物品转化为另一个。相反，这种攻击会生成一个与图像无关的补丁，这对神经网络来说非常显著。然后，这个补丁可以放在分类器视野范围内的任何地方，并使分类器输出一个目标类。因为这个补丁是独立于场景的，它允许攻击者创建一个物理世界的攻击，而不需要事先了解照明条件、摄像机角度、被攻击的分类器类型，甚至场景中的其他项目.</p>
<p><img src="C:\Users\xiwen\desktop\blog\source_posts\image-20230312220339004.png" alt="image-20230312220339004"></p>
<p>This attack is significant because the attacker does not need to know what image they are attacking when constructing the attack. After generating an adversarial patch, the patch could be widely distributed across the Internet for other attackers to print out and use. Additionally, because the attack uses a large perturbation, the existing defense techniques which focus on defending against small perturbations may not be robust to larger perturbations such as these. Indeed recent work has demonstrated that state-of-the art adversarially trained models on MNIST are still vulnerable to larger perturbations than those used in training either by searching for a nearby adversarial example using a different metric for distance [14], or by applying large perturbations in the background [1].</p>
<p>这种攻击很重要，因为攻击者在构建攻击时不需要知道他们攻击的是什么映像。生成对抗性补丁后，该补丁可以在互联网上广泛分发，供其他攻击者打印和使用。此外，由于攻击使用了较大的扰动，现有的防御技术侧重于防御小扰动，可能对诸如此类的较大扰动并不健壮。事实上，最近的工作已经证明，与训练中使用的模型相比，MNIST上最先进的对抗训练模型仍然容易受到更大的扰动，无论是通过使用距离[14]的不同度量来搜索附近的对抗示例，还是通过在背景[1]中应用大扰动。</p>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>The traditional strategy for finding a targeted adversarial example is as follows: given some classifier P [y | x], some input x ∈ Rn, some target class by and a maximum perturbation ε, we want to find the input bx that maximizes log (P [by | bx]), subject to the constraint that kx − bxk∞ ≤ ε. When P [y | x] is parameterized by a neural network, an attacker with access to the model can perform iterated gradient descent on x in order to find a suitable input bx. This strategy can produce a well camouflaged attack, but requires modifying the target image.</p>
<p>Instead, we create our attack by completely replacing a part of the image with our patch. We mask our patch to allow it to take any shape, and then train over a variety of images, applying a random translation, scaling, and rotation on the patch in each image, optimizing using gradient descent. In particular for a given image x ∈ Rw×h×c, patch p, patch location l, and patch transformations t (e.g. rotations or scaling) we define a patch application operator A(p, x, l, t) which first applies the transformations t to the patch p, and then applies the transformed patch p to the image x at location l (see figure 2).</p>
<p>寻找目标对抗示例的传统策略如下:给定一些分类器P [y | x]，一些输入x∈Rn，一些目标类by和一个最大扰动ε，我们想要找到最大log (P [by | bx])的输入bx，受kx−bxk∞≤ε的约束。当P [y | x]被神经网络参数化时，可以访问模型的攻击者可以对x进行迭代梯度下降，以找到合适的输入bx。这种策略可以产生很好的伪装攻击，但需要修改目标图像。</p>
<p>相反，我们通过用补丁完全替换图像的一部分来创建攻击。我们对我们的补丁进行遮罩，使其能够呈现任何形状，然后在各种图像上进行训练，对每个图像中的补丁应用随机平移、缩放和旋转，使用梯度下降进行优化。特别是对于给定的图像x∈Rw×h×c、补丁p、补丁位置l和补丁变换t(例如旋转或缩放)，我们定义了一个补丁应用算子a (p, x, l, t)，它首先将变换t应用于补丁p，然后将变换后的补丁p应用于位置l的图像x(见图2)。</p>
<p><img src="C:\Users\xiwen\desktop\blog\source_posts\image-20230312222034645.png" alt="image-20230312222034645"></p>
<p><img src="C:\Users\xiwen\desktop\blog\source_posts\image-20230312222420698.png" alt="image-20230312222420698"></p>
<p>where X is a training set of images, T is a distribution over transformations of the patch, and L is a distribution over locations in the image. Note that this expectation is over images, which encourages the trained patch to work regardless of what is in the background. This departs from most prior work on adversarial perturbations in the fact that this perturbation is universal in that it works for any background. Universal perturbations were identified in [9], but these required changing every pixel in the image and results were not given in the physical world.</p>
<p>其中X是图像的训练集，T是补丁变换的分布，L是图像中位置的分布。注意，这个期望是针对图像的，这鼓励训练过的补丁不管背景是什么都能工作。这与大多数先前关于对抗性扰动的工作不同，事实上这种扰动是普遍的，因为它适用于任何背景。在[9]中确定了普遍扰动，但这些扰动需要改变图像中的每个像素，并且在物理世界中没有给出结果。</p>
<p>We also consider camouflaged patches which are forced to look like a given starting image. Here we simply add a constraint of the form ||p − porig||∞ &lt; ? to the patch objective. This will force the final patch to be within ? in the L∞ norm of some starting patch porig.</p>
<p><img src="C:\Users\xiwen\desktop\blog\source_posts\image-20230312222652314.png" alt="image-20230312222652314"></p>
<p>我们还考虑了伪装补丁，这些补丁被迫看起来像给定的起始图像。这里我们只需添加一个形式为||p−porig||∞&lt; ?到补丁目标。这将迫使最终补丁在?的L∞范数。</p>
<p>我们认为这种攻击利用了图像分类任务的构造方式。虽然图像可能包含多个项目，但只有一个目标标签被认为是正确的，因此网络必须学会检测帧中最“突出”的项目。对抗性补丁通过产生比现实世界中的物体更显著的输入来利用这一特性。因此，当攻击目标检测或图像分割模型时，我们期望目标面包机补丁被归类为面包机，而不影响图像的其他部分。</p>
<h2 id="Experimental-Results"><a href="#Experimental-Results" class="headerlink" title="Experimental Results"></a>Experimental Results</h2><p>To test our attack, we compare the efficacy of two whitebox attacks, a blackbox attack, and a control patch. The white box ensemble attack jointly trains a single patch across five ImageNet models: inceptionv3, resnet50, xception, VGG16, and VGG19. We then evaluate the attack by averaging the win rate across all five models. The white box single model attack does the same but only trains and evaluates on a single model. The blackbox attack jointly trains a single patch across four of the ImageNet models, and then evaluates the blackbox attack on a fifth model, which we did not access during training. The control is a picture of a toaster.</p>
<p>为了测试我们的攻击，我们比较了两个白盒攻击、一个黑盒攻击和一个控制补丁的效果。白盒集合攻击在五个ImageNet模型(inceptionv3、resnet50、xception、VGG16和VGG19)上联合训练一个补丁。然后，我们通过平均所有五个模型的胜率来评估攻击。白盒单模型攻击也做同样的事情，但只在单个模型上训练和评估。黑盒攻击在四个ImageNet模型上联合训练一个补丁，然后在我们在训练期间没有访问的第五个模型上评估黑盒攻击。控件是一个烤面包机的图片。</p>
<p>During training and evaluation, the patches are rescaled and then digitally inserted on a random location on a random ImageNet image. Figure 2 shows the results.</p>
<p>Note that the patch size required to reliably fool the model in this universal setting (black box, on a targeted class, and over all images, locations and transformations) is significantly larger than those required to perform a non-targeted attack on a single image and a single location in the whitebox setting. For example, Su et al [6] recently demonstrated that modifying 1 pixel on a 32x32 pixel CIFAR-10 image (0.1% of the pixels in the image) suffices to fool the majority of images with a non-targeted, non-universal whitebox attack. However, our attacks are still far more effective</p>
<p>在训练和评估期间，补丁被重新缩放，然后以数字方式插入随机ImageNet图像上的随机位置。图2显示了结果。</p>
<p>请注意，在这个通用设置(黑盒，目标类，以及所有图像，位置和转换)中可靠地欺骗模型所需的补丁大小明显大于在白盒设置中对单个图像和单个位置执行非定向攻击所需的补丁大小。例如，Su等人[6]最近证明，在32x32像素的CIFAR-10图像上修改1个像素(图像中像素的0.1%)足以用非定向的、非通用的白盒攻击欺骗大多数图像。然而，我们的攻击仍然有效得多</p>
<p><img src="C:\Users\xiwen\desktop\blog\source_posts\image-20230312224047785.png" alt="image-20230312224047785"></p>
<p>图3:创建对抗补丁的不同方法的比较。注意，这些成功率是随机放置在图像顶部的补丁。图中的每个点都是通过将补丁应用于400个随机选择的测试图像中的随机位置来计算的。这是对图像大小的一小部分的不同比例的补丁进行的，每个比例在400张图像上进行独立测试。</p>
<p>We also tested the black box + physical world effectiveness of the patch on the third party Demitasse application2 and found some transferability of the patch but only when the patch takes up a significant fraction of the image. We did not optimize the patch for print-ability as in [13], which perhaps explains why the patch is not as effective as in Figure 3, which tests black box for different models and not in the physical world. We invite curious readers to try the patch out for themselves by printing out this paper and using the patch in the Appendix.</p>
<p>我们还在第三方Demitasse应用程序上测试了补丁的黑盒+物理世界的有效性，并发现了补丁的一些可移植性，但仅当补丁占用图像的很大一部分时。我们没有像[13]中那样优化补丁的打印能力，这可能解释了为什么补丁没有图3中那么有效，图3测试了不同模型的黑盒，而不是在物理世界中。我们邀请好奇的读者通过打印出这篇论文并使用附录中的补丁来尝试自己的补丁。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We show that we can generate a universal, robust, targeted patch that fools classifiers regardless of the scale or location of the patch, and does not require knowledge of the other items in the scene that it is attacking. Our attack works in the real world, and can be disguised as an innocuous sticker.</p>
<p>These results demonstrate an attack that could be created offline, and then broadly shared.</p>
<p>我们展示了我们可以生成一个通用的、健壮的、有针对性的补丁，无论补丁的规模或位置如何，它都可以欺骗分类器，并且不需要了解它正在攻击的场景中的其他项目。我们的攻击在现实世界中起作用，可以伪装成一个无害的贴纸。</p>
<p>这些结果证明了一种可以离线发起并广泛共享的攻击。</p>
<p>There has been substantial work on defending against small Lp perturbations to natural images, at least partially motivated by security concerns [12, 8, 2]. Part of the motivation of this work is that potential malicious attackers may not be concerned with generating small or imperceptible perturbations to a natural image, but may instead opt for larger more effective but noticeable perturbations to the input especially if a model has been designed to resist small Lp perturbations.</p>
<p>已经有大量的工作用于防御自然图像的小Lp扰动，至少部分是出于安全考虑[12,8,2]。这项工作的部分动机是，潜在的恶意攻击者可能不关心对自然图像产生小的或难以察觉的扰动，而是可能选择对输入产生更大、更有效但明显的扰动，特别是如果模型被设计为抵抗小的Lp扰动。</p>
<p>Many ML models operate without human validation of every input and thus malicious attackers may not be concerned with the imperceptibility of their attacks. Even if humans are able to notice these patches, they may not understand the intent of the patch and instead view it as a form of art. This work shows that focusing only on defending against small perturbations is insufficient, as large, local perturbations can also break classifiers.</p>
<p>许多ML模型在运行时没有对每个输入进行人工验证，因此恶意攻击者可能不关心其攻击的不可察觉性。即使人类能够注意到这些补丁，他们也可能不理解补丁的意图，而是将其视为一种艺术形式。这项工作表明，只专注于防御小扰动是不够的，因为大的局部扰动也可以破坏分类器。</p>
]]></content>
      <tags>
        <tag>Adverserial Attack</tag>
      </tags>
  </entry>
  <entry>
    <title>“关于多巴胺脱瘾”</title>
    <url>/2023/02/16/%E2%80%9C%E5%85%B3%E4%BA%8E%E5%A4%9A%E5%B7%B4%E8%83%BA%E8%84%B1%E7%98%BE%E2%80%9D/</url>
    <content><![CDATA[<h2 id="每天都上自己的博客看看吧"><a href="#每天都上自己的博客看看吧" class="headerlink" title="每天都上自己的博客看看吧"></a>每天都上自己的博客看看吧</h2><p>  当代互联网上琳琅满目的娱乐方式极大的提高了线代人们的多巴胺阈值, 在我自己的人生经历中, 这种感觉变得愈发的明显<span id="more"></span> 从小时候能够看到电视就会十分兴奋, 再到对b站的各种视频持续性的上瘾, 再到这些东西不再能让我感到快乐, 每一天都生活变得愈发麻木, 这样的坏处显而易见, 那就是我对于学习这样的事情的耐心和兴趣变得愈发的淡薄, 对于在学习技术与编程的过程中所遇到的困难愈发变得抗拒.</p>
<p>  于是, 多巴胺脱瘾, 这就是我为自己所指定的目标, 就是要培养自己的自控能力, 并在这个过程中努力避免来自新媒体以及游戏的高多巴胺刺激内容的诱惑, 这个过程会无聊到感到痛苦, 但是, 痛苦本身就往往意味着成长. 成长并不都是好事, 但是时间不会等人, 走到现在, 我愈发感觉到, 想要被自己真正认可究竟是多么困难的一件事情, 我已经让自己失望过了无数次, 前面的无数次我也是这么说的, 但是没有外界明显的压力的情况下人就是会这样不断的朝着低级娱乐的方向前进, 但这和我们自己的目标是绝对相互矛盾的, 我们不能被别人逼着走, 我尤为讨厌这种失去控制权的感觉, 所以, 我定下每天日记的计划, 让每一天的我都能够回顾自己前一天的所思所想, 自己逼迫自己去不断的反思纠正, 一旦发现有堕落的迹象就要以此文为例, 勉励自己.</p>
]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp算法学习笔记</title>
    <url>/2023/01/02/kmp%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><p>学习状态机的题目时，遇到一道题需要使用到kmp的知识，于是上csdn学习了一下并整理了如下笔记。</p>
<span id="more"></span>
<p>讲解视频： <a href="https://www.bilibili.com/video/BV1234y1y7pm">https://www.bilibili.com/video/BV1234y1y7pm</a></p>
<p>kmp: 一个人能能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。  ————KMP</p>
<p>kmp算法用于匹配字符串位置。<br>给定两个字符串：a, b 定义a为主串，b为模板串，kmp的任务就是检查主串中是否存在等同于b的字串。</p>
<h2 id="传统暴力方法"><a href="#传统暴力方法" class="headerlink" title="传统暴力方法"></a>传统暴力方法</h2><p>设定两个指针i, j，分别指向两个字符串的开头，然后一次向后匹配，若没有匹配，那么i回溯到原本的位置+1，j回溯到最开始继续匹配，直到完全匹配。<br>这样的方法完全没有从之前的失败经历中吸取到信息从而采取更好的策略，所以世间复杂度很高。</p>
<h2 id="kmp给出的答案"><a href="#kmp给出的答案" class="headerlink" title="kmp给出的答案"></a>kmp给出的答案</h2><p>kmp定义了一个字符串的前缀与后缀，在上述的方案中，回溯指针时是从头开始的，但是kmp不是这样的，在上述的匹配方案中，遇到第一个未匹配的字符时其前面的子串是完全相同的。我们要做的是找到该字串前缀与后缀相同的位置，然后将指针回溯到这里，这样，前后缀的部分一定是匹配的，可以省去许多无用功。<br>当回溯一次是若发现下一个字符还是不匹配，那么就让当前匹配的子串（即先前的前后缀）继续查找相同的前后缀，并回溯到这个位置，直到 j 指针指向0，就令i指针持续后移，直到i指针所指的对象与模板串的第一个字符相同。</p>
<p>那么如何查找上述方案中相同前后缀的位置呢，这里我们使用一个ne[]数组对模板串采用dp的方式进行记录其每个子串的前后缀长度情况。具体方法实际上还是kmp的思想。<br>具体方法如下：</p>
<ol>
<li>设置两个指针i，j，i&#x3D;2，j&#x3D;0；检查pi &#x3D;&#x3D; pj+1;</li>
<li>如果匹配，那么对于1-i的子串，他的最长公共前后缀的长度就是ne[]，而ne[i] &#x3D; j+1.</li>
<li>如果不匹配，则回溯j指针，使j &#x3D; ne[j]，直到匹配成功（kmp思想，这里将1-j的子串看作当前的前后公共子串）</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> p[N],s[N];</span><br><span class="line"><span class="comment">//next数组表示的是不匹配时子串下标退回的位置</span></span><br><span class="line"><span class="comment">//比如next[i]=j就表示在子串中p[1~j]=p[i-j+1~i]</span></span><br><span class="line"><span class="comment">//所以子串直接退回到j下标继续和主串进行模式匹配直到匹配成功为止</span></span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求next数组的过程</span></span><br><span class="line">    <span class="comment">//类似于KMP匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果子串没有退回到起点，并且主串和子串不匹配</span></span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j=ne[j];<span class="comment">//j退回到重合部分的终点位置</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i-n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="示例题目：周期"><a href="#示例题目：周期" class="headerlink" title="示例题目：周期"></a>示例题目：周期</h1><p>题目链接： <a href="https://www.acwing.com/problem/content/143/">141. 周期 - AcWing题库</a></p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>需要注意到kmp中的前缀ne[]函数与循环节之间的关系，如果在某一个前缀长度为s中存在长度为三的循环节，那么对应到该前缀子串的ne[]数组的特征就是s % (s-ne[s]) &#x3D;&#x3D; 0，且ne[s]不等于0；<br>证明：<br>作图，暂且称子串减去公共前后缀的部分为循环节，那么就可以发现循环节一定等于其后的一段等长的节，因为前后缀相等，循环节后面一节就是后缀开头的一节，而这一节同时又是前缀的第二节，那么可以得到前缀中第一节等于第二节，后缀则也是如此，而后缀的第二节又是前缀的第三节···如此这般，可以推导出当整除关系下，我们假设的循环节就是真正的循环节。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> t,i,j,n,nex[<span class="number">1000005</span>];<span class="type">char</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,++t);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//最基本的 next[] 数组求法</span></span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;a[i]!=a[j+<span class="number">1</span>])j=nex[j];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[j+<span class="number">1</span>])j++;nex[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//由于1～1只有一个字母，只能是它本身构成长度为1的循环，所以从2开始枚举</span></span><br><span class="line">            <span class="keyword">if</span>(i%(i-nex[i])==<span class="number">0</span>&amp;&amp;nex[i])<span class="comment">//判断时还要注意nex[i]是否为0</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,i/(i-nex[i]));</span><br><span class="line"><span class="comment">//如果i含有长度大于1的最小循环元，输出i的长度(即i)以及最大循环次数K(即i-nex[i])</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//记得输出一个空行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>不开long long见祖宗</title>
    <url>/2023/01/04/%E4%B8%8D%E5%BC%80long-long%E8%A7%81%E7%A5%96%E5%AE%97/</url>
    <content><![CDATA[<h1 id="感受差分的威力吧"><a href="#感受差分的威力吧" class="headerlink" title="感受差分的威力吧"></a>感受差分的威力吧</h1><p>题目链接： <a href="https://www.acwing.com/problem/content/description/4658/">4655. 重新排序 - AcWing题库</a></p>
<span id="more"></span>

<p>题目思路一开始我就有了，我想的是贪心+桶排序</p>
<p>贪心很好理解：我们将原数组排序，然后让重叠次数最多的地方填上最大的数字，然后依次后推，这样就得到了一开始最朴素的思路：</p>
<ol>
<li>使用前缀和计算出一般的sum</li>
<li>将原数组从大到小排序</li>
<li>使用桶排序统计出每个数字被检索的次数</li>
<li>为桶排序的结果排序</li>
<li>然后统计出排序后数组的答案：<code>res = a[i] * t[i]</code> 被检索几次就乘以几次加上去；</li>
<li>相减得到正确答案</li>
</ol>
<p>需要注意的是: <code>res = a[i] * t[i]</code>会爆int，然后憨憨的我改写成了 <code>res = (ll)(a[i] * t[i])</code>这样写实际上还是会爆int，太蠢了，计算完括号里的内容才ll就晚了，实际上应该这么写： <code>res = (ll) a[i] * t[i]</code>；一定要牢记</p>
<p>同时cmp 函数 return 时也要记得结果加上括号。</p>
<p>但是结果TLE，看了题解发现思路基本一样，但是题解使用的是差分统计检索情况，我不服，但是试了一下确实过了；</p>
<p>难道是因为比起桶排序，差分法少嵌套一层循环？我原本以为本题最吃时间复杂度的不是那里，现在想想确实有可能在那里被卡住；</p>
<p>但是还是长个记性吧，以后遇到这种情况还是用差分吧；</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], t[N];</span><br><span class="line">ll res;</span><br><span class="line">ll ress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        res += (sum[r] - sum[l<span class="number">-1</span>]);</span><br><span class="line">        t[l] ++, t[r+<span class="number">1</span>] --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i] += t[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">2</span>, cmp);</span><br><span class="line">    <span class="built_in">sort</span>(t+<span class="number">1</span>, t+n+<span class="number">2</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; t[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ress += (ll)t[i] * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ress - res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用django+canvas完成简单的网页游戏</title>
    <url>/2022/12/17/%E4%BD%BF%E7%94%A8django-canvas%E5%AE%8C%E6%88%90%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><em>最近买了acwing的django框架课学习使用django进行简单的网页游戏开发，虽然现在还没有学完，但是目前对于javascript使用canvas进行简单的游戏开发已经有了相对之前非常多的心得，故有此篇，之后关于用户系统和thrift联机对战的内容会单独出一篇文章</em></p>
<span id="more"></span>

<h1 id="初识django"><a href="#初识django" class="headerlink" title="初识django"></a>初识django</h1><h2 id="1-1进行远程开发的前期工作"><a href="#1-1进行远程开发的前期工作" class="headerlink" title="1. 1进行远程开发的前期工作"></a>1. 1进行远程开发的前期工作</h2><h3 id="为什么要远程开发："><a href="#为什么要远程开发：" class="headerlink" title="为什么要远程开发："></a>为什么要远程开发：</h3><p>因为对于当下的服务器部署应用开发而言，云盘，数据库以及 app 本身会被存放在不同的服务器中，这样在本地的环境与线上环境会产生较大的差异，需要进行调试的时候也会遇上难以解决的结构问题，故而最好的方法是直接通过ssh远程登陆到服务器上，直接在服务器上进行远程开发，这样就能根本上避免掉从本地部署到服务器过程中会出现的一系列问题。</p>
<h3 id="工具选择："><a href="#工具选择：" class="headerlink" title="工具选择："></a>工具选择：</h3><p>由于是django远程开发，故而有主要有三种选择：</p>
<ol>
<li>直接在终端使用vim或者nano进行代码编写；</li>
<li>在本地通过vscode远程登录到服务器上，使用code本身完善的图形化界面进行代码编写；</li>
<li>在本地使用pycharm通过sftp文件模式进行简介的远程代码编写；</li>
</ol>
<p>第一种是给大佬使用的，在使用之前你需要对vim或者nano的操作有相当程度的熟悉，但是即使不使用这种方式编写代码，也要有对这两个工具使用方法最基本的了解，因为对于需要管理员权限的文件的操作通常还是要在vim中进行的；</p>
<p>第二种是我目前开发所使用的方法，使用vscode相较于直接使用终端开发的优点主要在于方便的文件结构图视，熟悉的操作方式，以及更为好看的界面，但是受限于服务器本身孱弱的性能（1c2g），vscode的代码补全功能体验上阉割了不少，但是总归好过vim；</p>
<p>第三种方式应该是效率最高的方式，没有采用的原因是我自身更加希望通过避免使用ide来减少对其的依赖，因为ide过于周到的一条龙服务会使没有什么基础的小白对于一个项目所需要的各种知识的掌握有所欠缺，这点在后面会说明</p>
<h3 id="服务器搭建："><a href="#服务器搭建：" class="headerlink" title="服务器搭建："></a>服务器搭建：</h3><p>服务器选择的是阿里云的云服务器，1c2g，可以直接选择试用的服务器先白嫖一个月再说，在服务器中又加了一层docker容器，优点是方便将你的成果直接打包迁移，省去了配环境的许多工作，同时将不同的服务部署在不同的容器中，管理起来也更加安全方便，关于docker的各种指令可以参考以下网址：</p>
<p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3074146/">https://www.acwing.com/file_system/file/content/whole/index/content/3074146/</a></p>
<h2 id="1-2-django项目的文件结构的介绍"><a href="#1-2-django项目的文件结构的介绍" class="headerlink" title="1.2 django项目的文件结构的介绍"></a>1.2 django项目的文件结构的介绍</h2><p>项目初期可以对于整个游戏的规划不那么多，只先实现最基本的功能，只要你的文件结构合理，代码基地很扎实，那么后面依照模板添加新的内容也是很容易的，因此首先，我将这个游戏分成了三个板块：single mode, multi mode, settings. 之后止血药在项目的不同结构中均实现着三个板块即可. 对于项目文件的划分，主要分为：models, views, urls，这三者是主要实现django业务逻辑的模块，此外还有static文件夹存放静态文件(css, js, images)，以及templates存放html等基本网页，scripts存放配置脚本文件等。下面讲详细介绍这些文件：</p>
<ol>
<li>models实现的是“类”这样一个概念，它定义了数据库中一个类应有的各项属性，以及不同类之间的继承关系已方便数据库的管理</li>
<li>views实现的是整个项目中需要使用的所有方法，所有涉及python，django的操作，链路，各种逻辑都是通过views.py中的方法实现的，例如urls中的mappings是通过path和include方法实现的，某个映射的最终结果都是一个方法，在这个方法中会return一个str来作为最终返回的网页，当然这个str也并非说的那么简单，实际使用中，会使用一种叫render()的十分方便的函数.</li>
<li>urls实现的是从浏览器地址栏中输入内容到实际框架中方法（资源）的映射函数，如上所述，主要包括path()和include()，path是将url对应到方法的函数，include的是将一类开头的url对应到另一个urls.py文件中的mapping的方法。</li>
<li>static存放所有服务器提供服务所需要的静态文件，与之对应的media文件夹主要存放用户上传的静态文件，static与media都需要在app文件夹中的settings.py文件中添加对应的root(实际位置)和url(对应映射)注册，django会有自带的方法寻找这些static文件，另外通过命令<code>python3 manage.py collectstatic</code>可以网站中不同app的静态文件夹全部收集存放在一个总的static文件夹中，因此常常将这个命令直接添加到你调试所需要的shell脚本中。</li>
<li>templates没什么好说的，就是存放html文件。</li>
<li>script存放你调试网页，或者部署uwsgi的脚本文件，调试网页的脚本文件的实际作用类似于ide中的构建，将你刚刚写好的代码以服务需要的方式部署下来（因为方便写代码的文件结构通常不方便部署），例如游戏主题的js文件一共会有上千行，有着大量的class和复杂的继承关系，写到一个文件中通常就是一个灾难，但是如果通过树型的文件结构将他们管理起来就会十分利于开发，但是这样的文件结构在导入html时会十分麻烦，且需要经常更新，所以可以在script中利用shell编程将所有的js文件收集统筹到一个js文件中，最后导入这一个文件即可，之后每当写了新的代码只需要再运行一次这个代码即可。</li>
</ol>
<p>至此django项目的文件结构就介绍完了，而我的游戏项目存放在了<a href="https://gitee.com/xiwen-youmu/my-first-django">https://gitee.com/xiwen-youmu/my-first-django</a> 这个仓库中</p>
<h2 id="1-3-从哪里开始"><a href="#1-3-从哪里开始" class="headerlink" title="1.3 从哪里开始"></a>1.3 从哪里开始</h2><p>首先，你可以掏出你已经配置好环境的祖传docker镜像，或者创建一个新的docker容器，配置好django包，安装pip与python，nano，tmux（终端开服需要），然后就可以直接创建django项目了。创建一个新的django项目所需要的命令行代码这里就不再赘述        </p>
]]></content>
      <categories>
        <category>科技</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>django</tag>
        <tag>远程开发</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于一道集合性状压dp的题目</title>
    <url>/2023/01/03/%E5%85%B3%E4%BA%8E%E4%B8%80%E9%81%93%E9%9B%86%E5%90%88%E6%80%A7%E7%8A%B6%E5%8E%8Bdp%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="愤怒的小鸟（集合性状压dp）"><a href="#愤怒的小鸟（集合性状压dp）" class="headerlink" title="愤怒的小鸟（集合性状压dp）"></a>愤怒的小鸟（集合性状压dp）</h2><p>题目链接： <a href="https://www.acwing.com/problem/content/526/">524. 愤怒的小鸟 - AcWing题库</a></p>
<p>在题目条件下，两个点可以确定一条过原点的抛物线，有n个点，那么就可以预处理出n^2条抛物线，然后再预处理出每条抛物线最多经过多少个点，以及是哪些点。</p>
<span id="more"></span>

<p>这是一个重复覆盖问题，与之相对的就是精确覆盖问题；<br>这两个问题都已经有的最优解法：dancing links 这是一种数据结构（十字链表），可以优化dfs爆搜；</p>
<p>但是dancing links没学，这里用状压dp去达到相似的效果，优化爆搜；<br>爆搜的核心是：顺序，要以那种顺序枚举所有方案。以爆搜为基础思考优化方案；</p>
<p>优化方法：记忆化搜索（状压dp），注意到每一个state传入dfs函数都会唯一对应一个res解，因此我们可以使用一个f[state]将其存储下来<strong>避免重复计算</strong>。</p>
<p>x代表为当前state中未被覆盖的一列，path表示一条可以覆盖当前列的抛物线，new_state就可以用上述的公式求得。</p>
<p>两个过程的区别就是引入状压dp之后，有些已经被计算过的state再dfs再次遇到的时候不会被重复再计算一遍，大概可以优化一半多。<br>f中存储的就是当前状态下最少的抛物线数；<br>遇到相同的状态但是线数更多的时候就会被直接排除掉；<br>看看拦截导弹那一题；<br>path i, j 表示由第i个与第j个猪创建的抛物线经过了那些猪，使用二进制表示。</p>
<p>最后再总结一下这道题目的思路：</p>
<ol>
<li><p>使用pair读入个点；</p>
</li>
<li><p>利用任意两个点的位置求出抛物线集合path i, j i与j代表选择了第i和j个点，path中存储的是其经过的所有猪的二进制表达；</p>
</li>
<li><p>设置f为0x3f，f0 为0；</p>
</li>
<li><p>枚举所有的当前猪的位置情况（二进制）i，循环每一种情况中没有被干掉的猪x，枚举所有包含这个猪的抛物线path x, j，那么最终的状态转移方程就是：<br>  <code>f[i | path[x][j]] = min(f[i | path[i][j]], f[i]+1)</code></p>
</li>
</ol>
<p>  这样的状态转移方程的思想就是，将每一个f通过可以由哪一条合法的抛物线转移过来进行状态划分；所以这里以终点进行枚举，因为通过终点反推其组合时困难的；</p>
<p>  但是这里可以不采用集合的思想，将这道题看作一种记忆化搜索可以更便于你的理解；</p>
<p>  看一下如果爆搜当前任意一个抛物线时是否有更好的选择（f中的min），否则就将f更新为<code>f[i] + 1</code>，这样当就可以减去不必要的分枝，不行的转移方案直接剪掉，减少搜索花费；</p>
<ol start="5">
<li><p>另外需要注意一点，double比较的时候有可能出现误差，需要自己再写一个cmp函数用于比较；</p>
</li>
<li><p>fabs函数用于求浮点数的绝对值；<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">18</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>; <span class="comment">//这里</span></span><br><span class="line"></span><br><span class="line">PDD q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"><span class="type">int</span> path[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(a - b) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;q[i].x&gt;&gt;q[i].y;</span><br><span class="line">        <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span> path); <span class="comment">//记得每一次都要恢复原样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path[i][i] = <span class="number">1</span> &lt;&lt; i;<span class="comment">//防一手只给一个点的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> x1 = q[i].x, y1 = q[i].y;</span><br><span class="line">                <span class="type">double</span> x2 = q[j].x, y2 = q[j].y;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">cmp</span>(x1, x2)) <span class="keyword">continue</span>;  <span class="comment">// 在同一列的两个点不能作为构建抛物线的点</span></span><br><span class="line">                <span class="type">double</span> a = (y1 / x1 - y2 / x2) / (x1 - x2);</span><br><span class="line">                <span class="type">double</span> b = y1 / x1 - a * x1;</span><br><span class="line">                 <span class="comment">//if(a &gt; 0) continue; 这个写法被坑了一手</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">cmp</span>(a, <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">double</span> x3 = q[k].x, y3 = q[k].y;</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="built_in">cmp</span>(a* x3 * x3 + b * x3, y3)) state += <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">                &#125;</span><br><span class="line">                path[i][j] = state; <span class="comment">//全部抛物线预处理完成；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f); <span class="comment">//求最小值，初始化为inf；</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//一只猪没杀需要的抛物线数为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i+<span class="number">1</span> &lt; <span class="number">1</span> &lt;&lt; n; i++) <span class="comment">//dp基操，上来先将f的每一维按照一定顺序枚举一遍；同时全为1的状态不需要枚举，</span></span><br><span class="line">        &#123;                               <span class="comment">//因为就是答案，后面已经计算出来了</span></span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)<span class="comment">//检查一下哪一位为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i | path[x][j]] = <span class="built_in">min</span>(f[i | path[x][j]], f[i] + <span class="number">1</span>); <span class="comment">//多思考一下这个状态转移方程是怎么来的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于django用户系统的搭建流程</title>
    <url>/2022/12/18/%E5%85%B3%E4%BA%8Edjango%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="用户系统的搭建和登录界面的完成"><a href="#用户系统的搭建和登录界面的完成" class="headerlink" title="用户系统的搭建和登录界面的完成"></a>用户系统的搭建和登录界面的完成</h1><h2 id="1-1-向django自带数据库中添加自定义的类时需要注意的操作"><a href="#1-1-向django自带数据库中添加自定义的类时需要注意的操作" class="headerlink" title="1.1 向django自带数据库中添加自定义的类时需要注意的操作"></a>1.1 向django自带数据库中添加自定义的类时需要注意的操作</h2><p>启动uwsgi.ini服务之后<code>sudo uwsgi --ini scripts/uwsgi.ini</code>不要直接关闭终端，这样导致服务难以被关闭</p>
<span id="more"></span>

<p>如果无法关闭，则使用<code>sudo fuser -k 8000/tcp</code>杀死在8000端口的进程，在运行ini</p>
<p>登陆界面中的每个函数都要实现三个部分：</p>
<ol>
<li>views实现函数的本体</li>
<li>urls中实现函数的映射</li>
<li>js中实现对应的调用</li>
</ol>
<p>每一个处理请求的函数都要传入一个参数:request，请求登陆也是如此，并且导入包：<code>from django.http import JsonResponse</code></p>
<p>json文件：通用的序列化存储字典等内容的文件</p>
<p>path中填写的url最后一定带上&#x2F;，否则后面接新的东西时会出错</p>
<p>注意为文件添加可执行权限的操作是 chmod +x filename</p>
<p>js实现三秒后刷新：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>科技</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本博客的一些希望</title>
    <url>/2022/12/16/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%8C%E6%9C%9B/</url>
    <content><![CDATA[<p><em>关于本博客的一些初衷，首先写在这里，以勉励自己</em></p>
<span id="more"></span>



<h2 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h2><p>写博客的目的不在于给别人看，博客对我而言是一个特殊的笔记本，与普通的笔记本不同的是，博客中的内容并不是直接来源于一本书，一堂课，或者某一个视频，一篇博客的内容的直接生产者是我自己，一篇博客代表这我自己在这一段时间中获得的知识与感想的集合，它自成我的体系，它独属于我自己，写博客的过程，更似写一篇日记，我需要将自己的所思所想从心底全部引出，落在纸上（乐），这本身就是一种回顾，总结与加深，通过写博客，可以让一个人培养起不断反思，不断求深求全的习惯，我想这对自己的发展是大有脾益的。</p>
<p>提示：<code>&lt;!-- more --&gt;</code>可以手动分割文章，善用</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>初学数组模拟邻接表的一些理解</title>
    <url>/2022/12/24/%E5%88%9D%E5%AD%A6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="head与next数组中保存的是ver数组的下标"><a href="#head与next数组中保存的是ver数组的下标" class="headerlink" title="head与next数组中保存的是ver数组的下标"></a>head与next数组中保存的是ver数组的下标</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加入有向边(x, y)，权值为z；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">	ver[++tot] = y, edge[tot] = z; <span class="comment">//真实数据</span></span><br><span class="line">	next[tot] = head[x], head[x] = tot;</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<h2 id="理解方法："><a href="#理解方法：" class="headerlink" title="理解方法："></a>理解方法：</h2><p>tot为每一个数据编号，从第一个输入开始一直往后排，至于数据的输入顺序有关，与数据本身的性质无关<br>ver[++tot]因此就表示新录入一个数据，编号tot++；<br>对于一个以邻接表表示的有向图而言，表头head的下表表示起点的值，head的内容指向该起点最新加入的一条邻边终点的编号（即输入时的tot），next[tot]表示下表为tot的数据的后面接的数的编号；因为表头指针更新的是最新插入的数据，所以无需查找到末尾直接更新表头指向即可，因此有了：<br>next[tot] &#x3D; head[x], head[x] &#x3D; tot; 这样的操作。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包的二进制优化</title>
    <url>/2023/01/01/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>原理：对于任何一个数字而言，都可以分拆为几个单个的<code>2^k</code>相加，所以依据该物品的个数s，将其依次拆为若干个<code>2^k</code>组成的物品堆，将他们的体积和价值合并看待，之后再按照01背包的方法解决即可，因为这些<code>2^k</code>能够组合出0-s之间的任何一个数目</p>
<span id="more"></span>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">12010</span>;</span><br><span class="line"><span class="type">int</span> f[N], v[M], w[M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m; j&gt;=v[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题 第二周</title>
    <url>/2023/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<h1 id="选数异或"><a href="#选数异或" class="headerlink" title="选数异或"></a>选数异或</h1><p>题目： <a href="https://www.acwing.com/activity/content/problem/content/7908/">https://www.acwing.com/activity/content/problem/content/7908/</a></p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>类似于前缀和，相当于预先总结好那个范围中有可以异或匹配的数字对，然后查询时就会十分方便。这道题中使用了两种技巧：</p>
<ol>
<li>利用unordered_map做hash表将每对数字对记录下来，数字为关键字，映射值为数字的下标。</li>
<li>利用 dp 做对于预先总结数字对的匹配情况，dp[i]，代表再 1 - i 中含有的数字对中，左边界最大的值所在的下标。这样维护时只需要<code> dp[i]=max(dp[i−1],last[a⊕x])</code> 这是hash表查询的优势也发挥出来了。</li>
</ol>
<span id="more"></span>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>必要异或运算性质：<br>归零律：a⊕a&#x3D;0<br>结合律: a⊕b⊕c&#x3D;a⊕(b⊕c)&#x3D;(a⊕b)⊕c<br>交换律：a⊕b&#x3D;b⊕a<br>因此, a⊕b&#x3D;x⟺a⊕b⊕x&#x3D;0⟺a⊕x&#x3D;b<br>因此对于一个数a， 与a配对的数可以直接计算得出， 即为a⊕xa⊕x<br>递推优化<br>不妨将满足题意的两个数a, b简称为数对， a、b中较小的下标叫下界.<br>定义dp[i]为[1, i]区间中所有数对中的最大下界<br>如样例1 2 3 4, 只有2 3的异或为1.<br>对于区间[1, 2]它不包含数对{2， 3}所以 dp[2] 应该为一个无效值， 取0<br>对于区间[1, 3] [1, 4]， 都仅且包含数对{2, 3}, 所以dp[3] &#x3D; dp[4] &#x3D; 2</p>
<p>dp[r]的实际意义想必大家都看出来了， 就是当查询区间[l, r], 右边界为r时， 至少包含一个数对时的左边界最大值, 所以如果l小于等于这个左边界最大值， [l, r]区间内就至少有一个数对。</p>
<p>代码实现<br>用哈希表last[i]记录值i最后一次出现时的位置下标， dp[i]的求法是： 若ai⊕xai⊕x最后一次出现的下标要大于dp[i-1]， 则dp[i] &#x3D; last[ai⊕x]last[ai⊕x], 否则dp[i] &#x3D; dp[i-1]     </p>
<p>即<code> dp[i]=max(dp[i−1],last[a⊕x])</code></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">//使用一种类似于前缀和加dp的方法</span></span><br><span class="line"><span class="comment">//代码中使用了unordered_map，可以直接朴素地理解为一种不用担心越界的数组，方便你打hash表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], last[x ^ a]);</span><br><span class="line">        last[a] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt;(dp[r] &gt;= l ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h1><p>题目： <a href="https://www.acwing.com/problem/content/description/4647/">4644. 求和 - AcWing题库</a></p>
<p>使用了前缀和，但是实际上可以不用，求出总和依次相乘后除以2即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll cheng = (ll)(sum[n] - sum[i]);</span><br><span class="line">        ans += (ll)cheng * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题2022-10-30</title>
    <url>/2022/12/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022-10-30/</url>
    <content><![CDATA[<h1 id="上课睡觉"><a href="#上课睡觉" class="headerlink" title="上课睡觉"></a>上课睡觉</h1><p>题目：<br><a href="https://www.acwing.com/problem/content/description/4369/">https://www.acwing.com/problem/content/description/4369/</a></p>
<p>思路：<br>最终分配结果是每一堆的个数相同，则总堆数一定是sum的约数。补充知识：对于每一个数的平均约数都是logn个，推理过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一个数n，1-n中含有的2的倍数有n/2个，3的倍数有n/3个，以此类推，则总倍数有：1+n/2+n/3+......+n/n = nlnn个，然后倍数与约数又是一对相对的概念，所以约数大概为lnn个，为logn级别</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>所以解本题的思路为：寻找不同的cnt满足sum，然后依次检验cnt是否合法，最后找出最小的cnt(因为答案是n-sum&#x2F;cnt(动多少次就是原堆数减去现堆数))<br>如何检验是否合法：注意到能合并的堆一定是相互靠近的（这时候不要模拟实际的过程去思考，要抽象出最便于处理的本质），所以题目的本质就是将所给序列分割成一段段，每段sum都是cnt。</p>
<p>使用差分与前缀和的知识。一定可以确定的是，每一堆的石子必然大于等于0.</p>
<p>现预设一个cnt，然后从第一段开始检验，看看是否能够满足这个预设的cnt，然后再到后面去检验。<br>这样的话：枚举cnt是否成立时间复杂度为n，枚举约数时间复杂度为logn，总时间复杂度为nlogn，可以满足。<br>1e6下约数最多为240，则最多需要计算240*1e6次，c++一秒可以计算1e8次，所以稳过。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> cnt)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, s=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        s += w[i];</span><br><span class="line">        <span class="keyword">if</span>(s &gt; cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == cnt) s=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>( T-- ) &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum % i == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(sum/i)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n-i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题：能量石</title>
    <url>/2022/12/31/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E8%83%BD%E9%87%8F%E7%9F%B3/</url>
    <content><![CDATA[<h1 id="能量石"><a href="#能量石" class="headerlink" title="能量石"></a>能量石</h1><p>链接： <a href="https://www.acwing.com/problem/content/736/">734. 能量石 - AcWing题库</a></p>
<p>思路： 因为吃能量石的顺序会对物品的价值产生影响，所以要考虑的维度增多了，这时候要首先利用贪心的思路对能量石进行预先排序，注意到对于两件物品时，全部吃掉的情况下，<code>s[ i ] * l[ i+1 ] </code>即为当前顺序下会损失的能量值，这个值当然越小越好，所以对于假设要吃的所有物品，s&#x2F;l的值越小就说明它一定要先吃。<br>之前的考虑中没有考虑能量不能将为负数的情况，实际上只要将状态表达设置为时间恰好为j时的总能量值那么当能量降低为负数时就会对f产生负影响，只要遍历一遍求最大值就是题目所需的答案。</p>
<span id="more"></span>

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stone</span>&#123;</span><br><span class="line">    <span class="type">int</span> s, e, l;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Stone &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s * W.l &lt; l * W.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;stone[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> C=<span class="number">0</span>; C&lt;T; C++) &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> s, e, l;</span><br><span class="line">            cin&gt;&gt;s&gt;&gt;e&gt;&gt;l;</span><br><span class="line">            stone[i] = &#123;s, e, l&#125;;</span><br><span class="line">            m += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(stone, stone+n);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> s = stone[i].s, e = stone[i].e, l = stone[i].l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m; j&gt;=s; j--) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j-s]+e-(j-s)*l); <span class="comment">//在所有能量石降为负数时就自然不是最大值了，这样就省去了判断不能小于0的情况；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, C+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
